<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2021/02/07/Ajax%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/07/Ajax%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p> 三种请求方式</p><ol><li><p>$.get(url, [data], callback)</p></li><li><p>$.post(url, [data], callback)</p></li><li><p>$.ajax({url,method,data,success})<br>data 参数：可以是对象格式也可以是字符串格式，get 请求可以吧参数直接拼接到 url 后面</p><p>Form 表单</p></li><li><p>作用: 用来数据采集，收集用户填写的数据</p></li><li><p>组成部分：<br>form 标签<br>文本域  隐藏域 hidden  文件上传 file 复选框 checkbox<br>提交按钮</p></li><li><p>form 标签上的属性：<br>action 表单提交的 url 地址<br>target: _self/_blank 表示在新标签页还是当前页打开 url<br>method：get/post 请求方式<br>enctype: 参数的编码方式：<br>(1) application/x-www-form-urlencoded<br>(2) mutipart/form-data (二进制数，文件上传)<br>(3) text/plain</p></li><li><p>提交数据的缺点：<br>会刷新页面，之前的数据和状态会消失<br>采取的方案：使用 ajax 发送请求，避免页面的刷新</p><pre><code>    配合阻止表单的默认行为的方法：e.preventDefault()</code></pre></li><li><p>form 表单中的事件：<br>form.submit(function(e) {// 获取所有的表单参数 $(this).serialize() // 还原表单内容 this.reset()})       </p><p>模板引擎</p></li><li><p>所有的数据，变量，表达式，都必须用 双花括号 来进行包裹</p></li><li><p>渲染原本的 html 标签 @value</p></li><li><p>根据条件输出模板 if </p></li><li><p>循环遍历输出模板 each </p></li><li><p>过滤器：<br>template.defaults.imports.方法名(foo) = function(参数) {}</p><p>xhr 的新特性</p></li><li><p>设置请求超时的方法<br>xhr.timeout = 300<br>xhr.ontimeout = function() {}</p></li><li><p>使用 new FormData() 管理表单数据：<br>创建一个 formdata 数据 var fd = new FormData()<br>新增一条数据 fd.append(‘avatar’, ‘hello’)<br>遍历所有的数据 fd.forEach(fn)<br>设置某一条数据 fd.set(‘name’, ‘hello’)<br>一次性获取 form 表单中所有的内容 $(‘form’).serialize() 键值对字符串</p><pre><code>                        var fd = new FormData($(&#39;form&#39;)[0]) 获取 formdata 类型的表单数据</code></pre></li><li><p>实现文件上传的步骤：<br>获取用户上传列表 ipt.files<br>判断是否上传 ipt.files.length == 0<br>使用 formdata 去提交文件 fd.append(‘avatar’, ipt.files[0])<br>发送 ajax 的四部曲 var xhr = new XMLHttpRequest()</p><pre><code>           xhr.open(&#39;POST&#39;, url)           xhr.send(fd)</code></pre><p>xhr.onreadystatechange=function(){}                               </p></li><li><p>如何监听文件上传的进度<br>xhr.upload.onprogress = function(e) {e.loaded(已经上传的)/e.total(总数量) * 100}<br>xhr.upload.onload = function(e) {// 已经上传完成的}<br>特点：基于 Promise 的 Http请求库，可以同时在浏览器和Node.js平台使用<br>发送 GET 请求 axios.get(url?name=tom&amp;age=10)<br>.then(res =&gt; {console.log(res)})<br>.catch(res =&gt; {console.log(err)})<br>发送 POST 请求<br>axios.post(url, {name: ‘tom’, age: 10})<br>.then(res =&gt; {console.log(res)})<br>.catch(res =&gt; {console.log(err)})<br>axios({url:url,method: ‘get/post’,// get 请求params: {}// post 请求data: {}})<br>.then(res =&gt; {console.log(res)})<br>.catch(res =&gt; {console.log(err)})<br>返回数据 res (包装后的数据对象)，res.data [服务器真是响应的数据内容]</p><p>同源和跨域解决</p></li><li><p>同源的概念：两个 url 满足 协议，域名，端口号必须一致</p></li><li><p>同源策略：浏览器提供的一种安全策略，限制一个网站去放另一个网站的资源</p></li><li><p>跨域的原因：就是流浪器的同源策略</p></li><li><p>跨域的解决方案：<br>CORS 方案，服务端 的解决方案(在响应头中添加 Access-Content-Allow-Origin)<br>JSONP方案<br>代理服务器，前端本地开发(proxy 插件)<br>在流浪器中手动关闭同源策略</p></li><li><p>JSONP 的实现原理<br>利用 script 标签可以跨域的特性去请求资源</p></li><li><p>JQuery版本的JSONP实现：<br>核心： $.ajax({dataType: ‘jsonp’,jsonp: ‘cbk’,jsonpCallback: ‘foo’})</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>菜鸟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级</title>
    <link href="/2021/02/07/JS%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/07/JS%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p> 实例成员和静态成员</p><ol><li><p>只能通过实例对象才能访问道德属性和方法</p></li><li><p>只能通过构造函数本身才能访问的属性和方法</p><p>构造函数的原型</p></li><li><p>每个函数都有一个 prototype 属性，它的值是默认是一个对象</p></li><li><p>在 prototype 对象上的方法和属性会被 new 构造函数创建出来的实例对象所继承</p></li><li><p>注意： 只要有函数都具有 prototype 属性， 非函数不具有 prototype 属性</p><p>constructor 构造函数<br>如果修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用 constructor 指回原来的构造函数</p><p>原型链</p></li><li><p>当访问你对象的属性时，首先从这个对象自身进行查找 </p></li><li><p>如果没有找到就con他的原型对象 <strong>proto</strong> 中查找</p></li><li><p>如果还没有找到，继续沿着对象的原型链层层向上查找，直到最末尾的 null</p><p>数组方法</p></li><li><p>快速遍历数组  arr.forEach()</p></li><li><p>从数组中筛选出所有符合条件的元素  var res = arr.filter() 返回值是一个新数组</p></li><li><p>判断数组中是否存储某个符合条件的元素 arr.some()</p></li><li><p>判断数组中是否所有的元素都符合条件 arr.every()<br>区别：forEach 和 filter 会完整的遍历数组，some，every 不会</p><p>闭包(重点)</p></li><li><p>内部函数访问外部函数声明的变量，这种组合方式就叫做闭包</p></li><li><p>垃圾回收机制：垃圾回收机制会定期定期好处那些不再用到的内存，然后释放内存<br>闭包产身的原因： 当一个函数内声明的变量没有被其他的函数引用是，调用完这个函数后，所有的局部变量就会被垃圾回收机制清除</p><pre><code>         一旦这个变量被另一个函数所引用，这个变量的值会始终保存在内存中，不会被垃圾回收机制回收，从而形成了闭包</code></pre></li><li><p>闭包的作用：<br>优点： 延伸了变量的使用范围<br>   实现了数据的封装<br>   实现了数据的缓存<br>缺点：闭包会使得函数中的变量都被保存在内存中，加大了内存消耗<br>  容器引发内存泄漏</p><p>高阶函数</p></li><li><p>分类高阶函数是对其他函数进行操作的函数<br>把函数作为参数的函数<br>把函数作为返回值的函数</p><p>递归函数<br>函数内部自己调用自己，作用和循环效果类似<br>递归很容易发生栈溢出错误，所以和 while 循环类似必须要添加终端条件</p><p>浅拷贝和深拷贝</p></li><li><p>浅拷贝只拷贝对象一层的数据，复杂数据类型只拷贝内存地址值(引用同一个对象)</p></li><li><p>拷贝对象多层的数据，遇到复杂数据类型会继续新建一个空间，拷贝里面每一层的属性和值<br>区别：深拷贝后的对象和原型对象是完全隔离的，各自互不影响，而浅拷贝中所有的复杂数据类型的值都是共同引用的 </p><p>es6 声明变量：<br>let 声明变量：不会挂载到 window 上 </p><pre><code>      不会存在变量提升      暂存死区，存在但是访问不到      只在当前声明变量的块级或字块中使用      变量名不能重复</code></pre><p>正则表达式：<br>语法： new RegExp(/123/)</p><p>this 指向 (重点)</p></li><li><p>在构造函数中，里面的 this 指向的是对象实例，原型对象函数里面的 this 直线 的是实例对象</p></li><li><p>非函数作用域中的 this 指向window</p></li><li><p>函数中的 this 默认指向函数的调用者 其中 call，apply，bind 手动改变函数的 this 指向</p></li><li><p>严格模式下的 this 指向：<br>全部作用域中的 this 是 undefined<br>构造函数不加 new 调用， this 指向的是 undefined 如果给他赋值就会报错<br>定时器 this 还是指向 window</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>菜鸟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
